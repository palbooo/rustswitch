<!DOCTYPE html>
<html>
  <head>
    <title>Raven Guard (RVG) - Playground</title>
    <link rel="icon" type="image/x-icon" href="rvg.ico" />
    <!-- Styles bleiben unverändert -->
    <style>
      /* Vorhandene Styles bleiben gleich */
      body {
        font-family: Arial, sans-serif;
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
        background-color: #282c34;
        color: #ffffff;
        position: relative;
        min-height: 100vh;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }

      /* Der Rest der Styles bleibt unverändert */
      /* ... */

      /* Styling für die Verbindungs-Status-Anzeige */
      .reconnecting {
        color: #ff9800;
      }
    </style>
  </head>
  <body>
    <div class="header-container">
      <h1>Raven Guard (RVG) - Playground</h1>
      <div id="status" class="status">
        <div class="status-circle"></div>
      </div>
    </div>
    <div id="notification" class="notification"></div>
    <div id="cooldownMessage" class="cooldown-message"></div>

    <div class="panel-section">
      <div class="grid-container" id="switchGrid"></div>
    </div>

    <script>
      // Globale Variablen
      let ws;
      let reconnectAttempt = 0;
      const MAX_RECONNECT_DELAY = 5000;
      const switches = new Map();
      const grid = document.getElementById("switchGrid");
      const notification = document.getElementById("notification");
      const cooldownMessage = document.getElementById("cooldownMessage");
      let authenticated = false;

      // Hilfsfunktionen bleiben größtenteils unverändert
      function showNotification(message) {
        notification.textContent = message;
        notification.style.display = "block";
        setTimeout(() => {
          notification.style.display = "none";
        }, 5000);
      }

      function showCooldownMessage(message) {
        cooldownMessage.textContent = message;
        cooldownMessage.style.display = "block";
        setTimeout(() => {
          cooldownMessage.style.display = "none";
        }, 3000);
      }

      function handleAuth(message) {
        try {
          const data = JSON.parse(message);
          if (data.type === "auth") {
            if (data.status === "success") {
              authenticated = true;
              document.getElementById("status").className = "status";
              ws.send(JSON.stringify({ type: "loadSwitches" }));
            } else {
              document.getElementById("status").className = "status error";
              ws.close();
            }
          }
        } catch (err) {
          console.error("Error processing authentication message:", err);
        }
      }

      // Grid und Switch Funktionen bleiben unverändert
      function initializeGrid() {
        for (let row = 0; row < 5; row++) {
          for (let col = 0; col < 15; col++) {
            const cell = document.createElement("div");
            cell.className = "grid-cell";
            cell.dataset.position = `${row}-${col}`;
            grid.appendChild(cell);
          }
        }
      }

      function addSwitch(switchData, position) {
        const cell = document.querySelector(`[data-position="${position}"]`);
        if (!cell) return;

        const container = document.createElement("div");
        container.className = "switch-container";

        const button = document.createElement("button");
        button.className = "switch-button";
        button.dataset.switchId = switchData.switchId;
        button.classList.toggle("off", !switchData.lastState);
        button.addEventListener("click", () =>
          toggleSwitch(switchData.switchId)
        );

        container.appendChild(button);
        cell.innerHTML = "";
        cell.appendChild(container);
        switches.set(switchData.switchId, { ...switchData, position });
      }

      function loadExistingSwitches(switchesData) {
        switchesData.forEach((switchData) => {
          const position = `${switchData.position.row}-${switchData.position.col}`;
          addSwitch(switchData, position);
        });
      }

      function toggleSwitch(switchId) {
        const switchData = switches.get(switchId);
        if (!switchData) return;

        ws.send(
          JSON.stringify({
            type: "toggleSwitch",
            switchId: switchId,
            state: !switchData.lastState,
          })
        );
      }

      // Neue WebSocket Verbindungslogik
      function connect() {
        ws = new WebSocket(
          `${window.location.protocol === "https:" ? "wss:" : "ws:"}//${
            window.location.host
          }`
        );

        // Ping timeout handling
        ws.pingTimeout = null;

        function heartbeat() {
          clearTimeout(ws.pingTimeout);

          // Warte 5s länger als das Server Ping-Intervall (15s + 5s = 20s)
          ws.pingTimeout = setTimeout(() => {
            console.log("WebSocket Verbindung timeout - schließe Verbindung");
            ws.close();
          }, 20000);
        }

        ws.onopen = () => {
          console.log("WebSocket verbunden");
          document.getElementById("status").className = "status";
          reconnectAttempt = 0;
          heartbeat();
        };

        ws.onclose = () => {
          console.log("WebSocket getrennt");
          document.getElementById("status").className = "status error";
          clearTimeout(ws.pingTimeout);
          authenticated = false;

          // Exponentielles Backoff für Reconnect
          const delay = Math.min(
            1000 * Math.pow(2, reconnectAttempt),
            MAX_RECONNECT_DELAY
          );
          console.log(`Versuche Reconnect in ${delay}ms...`);
          showNotification(
            `Verbindung verloren. Reconnect in ${Math.round(
              delay / 1000
            )} Sekunden...`
          );

          setTimeout(() => {
            reconnectAttempt++;
            connect();
          }, delay);
        };

        ws.onerror = (error) => {
          console.error("WebSocket Fehler:", error);
          document.getElementById("status").className = "status error";
        };

        ws.onmessage = (event) => {
          heartbeat();

          try {
            const data = JSON.parse(event.data);

            if (data.type === "auth") {
              handleAuth(event.data);
              return;
            }

            switch (data.type) {
              case "switchesLoaded":
                loadExistingSwitches(data.switches);
                break;

              case "switchStateChanged":
                const button = document.querySelector(
                  `[data-switch-id="${data.switchId}"]`
                );
                if (button) {
                  button.classList.toggle("off", !data.state);
                  const switchData = switches.get(data.switchId);
                  if (switchData) {
                    switchData.lastState = data.state;
                  }
                }
                break;

              case "error":
                if (data.message.includes("warte noch")) {
                  showCooldownMessage(data.message);
                } else {
                  showNotification(data.message);
                }
                break;
            }
          } catch (error) {
            console.error("Error processing WebSocket message:", error);
          }
        };
      }

      // Initialisierung
      initializeGrid();
      connect();

      // Cleanup bei Page Unload
      window.addEventListener("beforeunload", () => {
        if (ws) {
          ws.close();
        }
      });
    </script>
  </body>
</html>
